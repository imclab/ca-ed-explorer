<!doctype html>
<meta charset="utf-8">
<title>California School Performance (2012)</title>
<style>

body,html{
   -webkit-transform: translate3d(0, 0, 0);
   -moz-transform: translate3d(0, 0, 0);
   -ms-transform: translate3d(0, 0, 0);
   transform: translate3d(0, 0, 0);
}

/*
.districts path{
  fill:#eee;
  stroke: white;
  stroke-width:.25px;
}

.districts path:hover{
  stroke-width: 2px;
}

div.tooltip {   
  position: absolute;           
  text-align: center;           
  padding: 5px 15px;             
  font-size: 10px;     
  background: white;
  border: 1px solid #ccc;      
  border-radius: 1px;  

  pointer-events: none;         
}    

.legend {
  font-size: 12px;
}*/


svg {
  font: 10px sans-serif;
}

.dimension.selected text{
  font-weight:bold;
}

.dimension.selected .domain{
  stroke-width:2px;
}

.background path {
  fill: none;
  stroke: #ccc;
  stroke-opacity: .3;
  shape-rendering: crispEdges;
}

.foreground path {
  fill: none;
  stroke: steelblue;
  stroke-opacity: .3;
}

.brush .extent {
  fill-opacity: .3;
  stroke: #fff;
  shape-rendering: crispEdges;
}

.axis line,
.axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  text-shadow: 0 1px 0 #fff;
  cursor: move;
}
</style>
<body>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="colorbrewer.js"></script>

<script>

queue()
  .defer(d3.json, "ca.sd.topo.json")
  .await(draw);

var m = [30, 10, 10, 10],
    w = 1560 - m[1] - m[3],
    h = 500 - m[0] - m[2];

var x = d3.scale.ordinal().rangePoints([0, w], 1),
    y = {},
    dragging = {};
var s = 10;

function parallelCoordinateInterpolator(points){
  var point, 
    action = '', 
    lineBuilder = [];

  for(var i = 0; i < points.length - 1; i++){
    point = points[i];

    if(isNaN(point[1])){
      if(action !== '') action = 'M';
    } else {
      lineBuilder.push(action, point);
      action = 'L';
    }
  }
  
  point = points[points.length - 1];
  if(!isNaN(point[1])){
    lineBuilder.push(action, point);
  }

  return lineBuilder.join('');
}

var line = d3.svg.line().interpolate(parallelCoordinateInterpolator),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground;

var svg = d3.select("body").append("svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

var properties;
function draw(err, sd){
  var districts = topojson.feature(sd, sd.objects.districts).features;
  var s= 10;
  var propertyKeys = Object.keys(districts[0].properties);
  // get properties and ensure they all have values
  properties = districts.slice(0).filter(function(d){
    return d.properties.API;
  }).map(function(d){
    var props = d.properties;

    var data = {
      API: props.API,
      AS_API: props.AS_API,
      FI_API: props.FI_API,
      MR_API: props.MR_API,
      WH_API: props.WH_API,
      HI_API: props.HI_API,
      AI_API: props.AI_API,
      AA_API: props.AA_API,
      EL_API: props.EL_API,
      SD_API: props.SD_API,
      DI_API: props.DI_API,
      PCT_WH: props.PCT_WH,
      PCT_HI: props.PCT_HI,
      PCT_AS: props.PCT_AS,
      PCT_AA: props.PCT_AA,
      PCT_AI: props.PCT_AI,
      PCT_MR: props.PCT_MR,
      PCT_FI: props.PCT_FI,
      PCT_PI: props.PCT_PI,
      PI_API: props.PI_API,
      HSG: props.HSG,
      SOME_COL: props.SOME_COL,
      COL_GRAD: props.COL_GRAD,
      GRAD_SCH: props.GRAD_SCH,
      ACS_46: props.ACS_46,
      ENROLL: props.ENROLL,
    };
  
    propertyKeys.forEach(function(key){
      if(!(key in data)) return; 
      var value = data[key];
      if(value === undefined || isNaN(value)){
        data[key] = undefined;
        if(s-- > 0) console.log(props);
      }
    });

    return data;
  });

  var property = 'API';
  
  // Extract the list of dimensions and create a scale for each.
  x.domain(dimensions = d3.keys(properties[0]).filter(function(d) {
    var domain;

    if(~d.indexOf('API')){
      domain = [200, 1000];
    } else if(~d.indexOf('PCT') || ~d.indexOf('GRAD_SCH')) {
      domain = [0, 100];
    } else {
      domain = d3.extent(properties, function(p) { return +p[d]; });
    }

    return (y[d] = d3.scale.linear()
        .range([h, 0]))
        .domain(domain);
  }));


  // Add grey background lines for context.
  background = svg.append("g")
      .attr("class", "background")
    .selectAll("path")
      .data(properties)
    .enter().append("path")
      .attr("d", path);

  // Add blue foreground lines for focus.
  foreground = svg.append("g")
      .attr("class", "foreground")
    .selectAll("path")
      .data(properties)
    .enter().append("path")
      .attr("d", path);

  property;
  function setProperty(p){
    console.log('Set property', p);
    property = p;
    
    if(!p) return foreground.style('stroke', '');

    var color = getColorer(districts, p);
    foreground.style('stroke', function(d){ 
        if(!d[p]) return 'gray';
        return color(d[p]);   
      });
  }

  // Add a group element for each dimension.
  var g = svg.selectAll(".dimension")
      .data(dimensions)
    .enter().append("g")
      .attr("class", "dimension")
      .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
      .on('click', function(d){
        if (d3.event.defaultPrevented) return; // click suppressed
        svg.selectAll('.dimension.selected').attr('class', 'dimension');
        if(property === d) return setProperty('');
        d3.select(this).attr('class', 'dimension selected');
        setProperty(d);
      })
      .call(d3.behavior.drag()
        .on("dragstart", function(d) {
          dragging[d] = this.__origin__ = x(d);
          background.attr("visibility", "hidden");
        })
        .on("drag", function(d) {
          dragging[d] = Math.min(w, Math.max(0, this.__origin__ += d3.event.dx));
          foreground.attr("d", path);
          dimensions.sort(function(a, b) { return position(a) - position(b); });
          x.domain(dimensions);
          g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
        })
        .on("dragend", function(d) {
          delete this.__origin__;
          delete dragging[d];
          d3.select(this).attr("transform", "translate(" + x(d) + ")");
          foreground.attr("d", path);
          background.attr("d", path)
              .attr("visibility", null);
        }));

  // Add an axis and title.
  g.append("g")
      .attr("class", "axis")
      .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
    .append("text")
      .attr("text-anchor", "middle")
      .attr("y", -9)
      .text(String);

  // Add and store a brush for each axis.
  g.append("g")
      .attr("class", "brush")
      .each(function(d) { 
        d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush)); 
      })
    .selectAll("rect")
      .attr("x", -8)
      .attr("width", 16);
}

function position(d) {
  var v = dragging[d];
  return v == null ? x(d) : v;
}

// Returns the path for a given data point.
function path(d) {
  return line(dimensions.map(function(p) { 
    if(~p.indexOf('API') && d[p] < 200){
      // if an api has a value under 200, mark it as invalid data
      // by setting index 1 to undefined
      return [position(p)];
    }
    return [position(p), y[p](d[p])]; 
  }));
}

// When brushing, donâ€™t trigger axis dragging.
function brushstart() {
  d3.event.sourceEvent.stopPropagation();
}

function getActive(){
  var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
      extents = actives.map(function(p) { return y[p].brush.extent(); });
  
  var p = properties.filter(function(d){
    return actives.every(function(p, i) {
      return extents[i][0] <= d[p] && d[p] <= extents[i][1];
    });
  });
}

// Handles a brush event, toggling the display of foreground lines.
function brush() {
  var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
      extents = actives.map(function(p) { return y[p].brush.extent(); });
  
  console.log(getActive());
  foreground.style("display", function(d) {
    return actives.every(function(p, i) {
      return extents[i][0] <= d[p] && d[p] <= extents[i][1];
    }) ? null : "none";
  });
}

function getColorer(features, property){
  var range = colorbrewer.RdYlGn[10].slice(0);
  var min = 1e15, max = 0;

  features.forEach(function(feature){
    var value = feature.properties[property];

    if(value < min ) min = value;
    else if(value > max) max = value;
  });

  if(~property.indexOf('API')){
    min = 200;
    max = 1000; 
  } else {
    switch(property){
      case 'ACS_46':
      case 'NOT_HSG':
        range = range.reverse();
        min = 0;
        max = 100;
        break;
      case 'HSG':
      case 'SOME_COL':
      case 'COL_GRAD':
      case 'GRAD_SCH':
        min = 0;
        max = 100;
        break;

    }
  }

  return d3.scale.quantile()
    .range(range)
    .domain([min, max]);
}

</script>

<script>
/*
var width = 960,
    height = 800;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

queue()
  .defer(d3.json, "ca.sd.topo.json")
  .await(draw);
  
var tooltip = d3.select("body").append("div")   
  .attr("class", "tooltip")               
  .style("opacity", 0);

function draw(err, sd){
  var projection = d3.geo.albers().scale(4500).translate([width/2, height/2]).rotate([120,1.5]);

  var zoom = d3.behavior.zoom()
    .translate(projection.translate())
    .scale(projection.scale())
    .scaleExtent([height / 8, 80 * height])
    .on("zoom", function zoomed() {
      projection.translate(d3.event.translate).scale(d3.event.scale);
      redraw(d3.event.scale);
    });

  svg.call(zoom);

  var path =  d3.geo.path().projection(projection);
  var districts = topojson.feature(sd, sd.objects.districts).features;
  var districtsGroup = svg.append('g')
          .attr('class', 'districts');

  function getMinMax(features, property){
    var min = 1e15,
      max = 0;

    features.forEach(function(feature){
      var value = feature.properties[property];

      if(value < min ) min = value;
      else if(value > max) max = value;
    });

    if(~property.indexOf('_API')){
      min = 200;
      max = 1000; 
    } else {
      switch(property){
        case 'ACS_46':
        case 'NOT_HSG':
          min = 100;
          max = 0;
          break;
        case 'HSG':
        case 'SOME_COL':
        case 'COL_GRAD':
        case 'GRAD_SCH':
          min = 0;
          max = 100;
          break;

      }
    }

    return [min, max];
  }

  function getColorer(features, property){
    var range = colorbrewer.RdYlGn[10].slice(0);
    var min = 1e15, max = 0;

    features.forEach(function(feature){
      var value = feature.properties[property];

      if(value < min ) min = value;
      else if(value > max) max = value;
    });

    if(~property.indexOf('API')){
      min = 200;
      max = 1000; 
    } else {
      switch(property){
        case 'ACS_46':
        case 'NOT_HSG':
          range = range.reverse();
          min = 0;
          max = 100;
          break;
        case 'HSG':
        case 'SOME_COL':
        case 'COL_GRAD':
        case 'GRAD_SCH':
          min = 0;
          max = 100;
          break;

      }
    }

    return d3.scale.quantile()
      .range(range)
      .domain([min, max]);
  }

  function setProperty(property){
    console.log('Setting property to', property);

    districtsGroup.selectAll('path').remove();
    var paths = districtsGroup.selectAll('path')
        .data(districts);

    var color = getColorer(districts, property);
    paths.enter().append('path')
        .style('fill', function(d){ 
          if(!d.properties[property]) return '';
          return color(d.properties[property]);   
        })
        .on("mousemove", function(d){
          tooltip
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY -30) + "px");
        })
        .on("mouseover", function(d) {
          if(!d.properties.District) return;
          
          tooltip
            .transition()
            .duration(300)
            .style("opacity", 1)
          tooltip.text(d.properties.District + " - " + d.properties[property] + " " + property)
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY -30) + "px");
        })
        .on("mouseout", function() {
          tooltip.transition().duration(300)
          .style("opacity", 0);
        });



    var colorDomainMin = color.domain()[0];
    var colorDomainMax = color.domain()[1];
    var legendSteps = 5;
    var colorStep = (colorDomainMax - colorDomainMin) / legendSteps
    var legendDomain = [];
    var legendLabels = [];
    var legendValueStart, legendValueEnd;
    for(var i = 0; i < legendSteps; i++){
      legendValueStart =  (colorDomainMin + colorStep * i)|0;
      legendValueEnd = (colorDomainMin + colorStep * (i + 1) - 1)|0;
      legendDomain.push(legendValueStart);
      legendLabels.push(legendValueStart + ' - ' + legendValueEnd);
    }

    svg.selectAll("g.legend").remove();
    var legend = svg.selectAll("g.legend")
                    .data(legendDomain)
                    .enter().append("g")
                    .attr("class", "legend");

    var ls_w = 20, 
        ls_h = 20;

    legend.append("rect")
          .attr("x", 20)
          .attr("y", function(d, i){ return height - (i*ls_h) - 2*ls_h;})
          .attr("width", ls_w)
          .attr("height", ls_h)
          .style("fill", function(d, i) { return color(d); })
          .style("opacity", 0.8);

    legend.append("text")
          .attr("x", 50)
          .attr("y", function(d, i){ return height - (i*ls_h) - ls_h - 4;})
          .text(function(d, i){ return legendLabels[i]; });

    redraw();
  }

  function redraw(){
    districtsGroup.selectAll('path').attr('d', path);
  }
  window.sp =setProperty;
  setProperty('API');
}
*/
</script>